#version 400 core
#extension GL_ARB_shading_language_420pack : require

in vec3 frag_pos_world;
in vec3 normal_world;
out vec4 frag_color;

//lights
const int MAX_LIGHT_NUMBER = 10;

struct
Sun
{
	vec4 col;
	vec4 dir;
};

struct
Lamp
{
	vec4 col;
	vec4 pos;
	float max;
};

struct
Suns
{
	int count;
	Sun arr[MAX_LIGHT_NUMBER];
};

struct
Lamps
{
	int count;
	Lamp arr[MAX_LIGHT_NUMBER];
};

//uniforms
layout (std140, binding = 1) uniform Object_Color
{
	vec4 object_color;
};

layout (std140, binding = 2) uniform Camera
{
	vec4 camera_pos;
};

layout (std140, binding = 3) uniform Directional_Lights
{
	Suns suns;
};

layout (std140, binding = 4) uniform Point_Lights
{
	Lamps lamps;
};

vec3
directional_light_calc(vec3 light_c, vec3 light_d, vec3 normal)
{
	//ambient (distrubuted light over the space)
	float ambient_strength = 0.1f;
	vec3 ambient = ambient_strength * light_c;

	//diffuse (scatterd light according to the material)
	vec3 diffuse = max(dot(normal, -light_d), 0.0f) * light_c;

	//specular (shinning)
	vec3 view_dir = normalize(camera_pos.xyz - frag_pos_world);
	vec3 reflected_light = reflect(light_d, normal);
	vec3 specular = 0.5f * pow(max(dot(view_dir, reflected_light), 0.0), 128) * light_c;

	return ambient + diffuse + specular;
}

void
main()
{
	vec3 result = vec3(0);

	//directional lights
	for(int x = 0; x < suns.count; ++x)
	{
		//interpolation in the setup triangle phase while rasterization not necasserily gives you a normal with mag = 1
		result += directional_light_calc(suns.arr[x].col.xyz, suns.arr[x].dir.xyz, normalize(normal_world)) * object_color.xyz;
	}

	frag_color = vec4(result, 1.0);
}