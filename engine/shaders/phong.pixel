#version 400 core
#extension GL_ARB_shading_language_420pack : require

in vec3 frag_pos_world;
in vec3 normal_world;
out vec4 frag_color;

//lights
const int MAX_LIGHT_NUMBER = 10;

struct
Sun
{
	vec4 col;
	vec4 dir;
};

struct
Lamp
{
	vec4 col;
	vec4 pos;
	float cutoff_dist;
};

struct
Suns
{
	int count;
	Sun arr[MAX_LIGHT_NUMBER];
};

struct
Lamps
{
	int count;
	Lamp arr[MAX_LIGHT_NUMBER];
};

//uniforms
layout (std140, binding = 1) uniform Object_Color
{
	vec4 object_color;
};

layout (std140, binding = 2) uniform Camera
{
	vec4 camera_pos;
};

layout (std140, binding = 3) uniform Directional_Lights
{
	Suns suns;
};

layout (std140, binding = 4) uniform Point_Lights
{
	Lamps lamps;
};

//calc ambient, diffuse and spec components
vec3
ads_calc(vec3 light_c, vec3 light_d, vec3 view_d, vec3 normal)
{
	//ambient (distrubuted light over the space)
	float ambient_strength = 0.1f;
	vec3 ambient = ambient_strength * light_c;

	//diffuse (scatterd light according to the material)
	vec3 diffuse = max(dot(normal, -light_d), 0.0f) * light_c;

	//specular (shinning)
	vec3 reflected_light = reflect(light_d, normal);
	vec3 specular = 0.5f * pow(max(dot(view_d, reflected_light), 0.0), 128) * light_c;

	return ambient + diffuse + specular;
};

vec3
directional_light_calc(Sun sun, vec3 normal)
{
	vec3 light_c = sun.col.xyz;
	vec3 light_d = sun.dir.xyz;
	vec3 view_d = normalize(camera_pos.xyz - frag_pos_world);
	vec3 result = ads_calc(light_c, light_d, view_d, normal);

	return result;
}

vec3
point_light_calc(Lamp lamp, vec3 normal)
{
	vec3 light_c = lamp.col.xyz;
	vec3 light_p = lamp.pos.xyz;
	vec3 light_d = normalize(frag_pos_world- light_p);
	vec3 view_d = normalize(camera_pos.xyz - frag_pos_world);
	vec3 result = ads_calc(light_c, light_d, view_d, normal);

	//we use a similar cutoff smooth attenuatuion fn as in unreal engine
	float d = length(frag_pos_world - light_p);
	float attenuation = clamp(1 - pow((d/lamp.cutoff_dist), 2) , 0, 1);

	return result * attenuation;
}

//interpolation in the setup triangle phase while rasterization not necasserily gives you a normal with mag = 1
void
main()
{
	vec3 result = vec3(0);

	//directional lights
	for(int x = 0; x < suns.count; ++x)
		result += directional_light_calc(suns.arr[x], normalize(normal_world)) * object_color.xyz;

	//point lights
	for(int x = 0; x < lamps.count; ++x)
		result += point_light_calc(lamps.arr[x], normalize(normal_world)) * object_color.xyz;

	frag_color = vec4(result, 1.0);
};