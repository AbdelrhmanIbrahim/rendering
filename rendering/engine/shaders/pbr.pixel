#version 330 core

uniform vec3 object_color_albedo;
uniform vec3 light_color;
uniform vec3 light_pos_world;
uniform vec3 camera_pos_world;

uniform float metallic;
uniform float rough;

in vec3 frag_pos_world;
in vec3 normal_world;

out vec4 FragColor;

const float PI = 3.14159265359f;

/*
Physically Based Rendering is all about simulate light interactions with surfaces in much more realistic and physical based way 
taking surface structure and energy conservation law into consideration by calculating the emissive and reflectance part for a surface.

This calculation is based on what's called Rendering Equation, which calculates how much light energy at a given point in space :
1) Irradiance : how much flux of all the incoming light waves at a certain area (reflectance)
2) Emission : how much energy the body emits, in case of the surface is emissive which is not in our cases (emission)

Usually in our case, we work on a simplified eqn of the Rendering eqn which ignores the emission part, we call it Reflectance eqn
that's all about how many lighting rays hitting a certain point on a surface to calculate how bright it is, but with taking the surface micro-structure into consideration.

Phong is a much simplified eqn of the relectance eqn but not considering the surface micro-structure and not physically based 
as it doesn't care about the energy conservation law (reflectance and refraction).

All the incoming functions is used to determine what is know as a bidirectional reflective distribution function (BRDF)
which is a major part of the reflectance eqn and determines how light rays interacts with the object and how much each individual light ray contributes
to the final reflected light of an opaque surface given its material properties.

The following 3 functions used to determines BRDF. (we use Cook-Torrance BRDF)
*/

/*
1) Normal Distribution Function that shows how many of the microfaces of the object is aligned to the halfway vector.
this contributes in the shinning and specular part, we use Trowbridge-Reitz GGX method
*/
float
NDF_GGX(vec3 normal, vec3 halfway, float roughness)
{
	float r = roughness*roughness;
	float r2 = r*r;
	float dot = max(dot(normal, halfway), 0.0);
	float dot2 = dot*dot;
	float nom   = r2; 
	float denom = (dot2 * (r2 - 1.0) + 1.0);
	denom = PI * denom * denom;
	return nom / max(denom, 0.001); //in case of zero denom
}

/*
2) Geometry Function used to approximate microfaces geomtery and their interactions with light dir and view dir
geometry shadowing with light dir through the microfaces + geometry obstruction with view dir which is blocking the reflected light dir from viewer
contributes in the shadowing through the surface, we use Smith's method
*/
float
Geomtery_Schlick_GGX(float dot, float roughness)
{
	//direct not an IBL
    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
	float nom   = dot;
	float denom = dot * (1.0 - k) + k;
	return nom / denom;
}
float
Geometry_Smith(vec3 normal, vec3 view_dir, vec3 light_dir, float roughness)
{
	float nv = max(dot(normal, view_dir), 0.0);
	float nl = max(dot(normal, light_dir), 0.0);
	float ggx1 = Geomtery_Schlick_GGX(nv, roughness);
	float ggx2 = Geomtery_Schlick_GGX(nl, roughness);
	return ggx1 * ggx2;
}

/*
3) Fresnel Function calculates how reflective the surface is which is the ratio of the reflections to the refractions
according to the viewer angle, we use Fresnel-Schlick method. (google Fresnel effect and check any image)
*/
vec3
Fresnel_Schlick(float halfway_view_dot, vec3 base_reflectivity)
{
    return base_reflectivity + (1.0 - base_reflectivity) * pow(1.0 - halfway_view_dot, 5.0);
}

//Cook-Torrance BRDF
vec3
BRDF(vec3 normal, vec3 light_dir, vec3 view_dir, float roughness)
{
	//NDF
	vec3 halfway = normalize(view_dir + light_dir);
	float D = NDF_GGX(normal, halfway, roughness);

	//Fresnel, calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 
    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)
	vec3 F0 = vec3(0.04); 
    F0 = mix(F0, object_color_albedo, metallic);
	vec3 F = Fresnel_Schlick(clamp(dot(halfway, view_dir), 0.0, 1.0), F0);

	//Geometry
	float G = Geometry_Smith(normal, view_dir, light_dir, roughness);

	//specular
	vec3 nom = D * F * G;
	float deno = 4 * max(dot(normal, view_dir), 0.0) * max(dot(normal, light_dir), 0.0);
	vec3 specular = nom/ max(deno, 0.001);

	//diffuse (taking metallic surfaces into consideration, metallic surfaces doesn't has diffuse part as it reflects all the light)
	vec3 kD = (vec3(1.0) - F) * (1.0 - metallic); 
	vec3 diffuse = (kD * object_color_albedo / PI);

	return (diffuse + specular);
}

void main()
{
	//reflectance eqn (irradiance)
	vec3 light_dir = normalize(light_pos_world - frag_pos_world);
	vec3 view_dir = normalize(camera_pos_world - frag_pos_world);
	float nl = max(dot(normal_world, light_dir), 0.0);
	vec3 Lo = BRDF(normal_world, light_dir, view_dir, rough) * light_color * nl;

	//ambient lighting (IBL will replace this ambient lighting with environment lighting)
	float ao = 1.0f;
    vec3 ambient = vec3(0.1) * object_color_albedo * ao;
    vec3 color = ambient + Lo;
    FragColor = vec4(color, 1.0);
}